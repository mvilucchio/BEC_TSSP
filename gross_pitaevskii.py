import numpy as np
from numpy import fft
import matplotlib.pyplot as plt

def freq_maker(N):
    """
    Wrapper for the creation of frequencies used in the following spectral method.
    ...

    Parameters
    ----------
    N : integer
        Number of division on the grid

    Returns
    -------
    ndarray
        Frequencies generated by fourier transform.
    """
    return 2 * np.pi * fft.fftfreq(N, d = 2*np.pi/N)


def TSSP_1d(M, N, a, b, psi0, dt, k, eps, k, save_each=30):

    psi = np.empty((N, M), dtype=complex) # lines <-> time, columns <-> space

    x = np.linspace(0, 1, M, endpoint=False)
    t = np.linspace(0, N*dt, N, endpoint=False)
    mu = np.array([2*np.pi*l for l in range(M)])

    psi[0,:] = psi0(x)

    for n in range(N-1):
        psin = psi[n,:]

        psi1 = np.exp(-1j*(x**2/2+k*np.abs(psin)**2)*dt/(2*eps))*psin
        psi2 = np.fft.ifft( np.exp(-1j*eps*dt*mu**2/2) * np.fft.fft(psi1) )
        psi[n+1,:] = np.exp(-1j*(x**2/2+k*np.abs(psi2)**2)*dt/(2*eps))*psi2

    return t, x, psi



def TSSP_2d(M, N, a, b, psi0, dt, k1, eps, save_each=30):

    psi = np.empty((N, M, M), dtype=complex)

    x = np.linspace(a, b, M, endpoint=False)
    y = np.linspace(a, b, M, endpoint=False)
    X, Y = np.meshgrid(x, y, sparse=False, indexing="ij")
    t = np.linspace(0, N*dt, N, endpoint=False)

    psi[0,:] = psi0(X, Y)

    for i in range(1, N):
        ps = psi[i-1,:]
        psi1 = ps * np.exp(-1j*((x**2+y**2)/2+k1*np.abs(ps)**2)*dt/(2*eps))
        psihat1 = fft.fft2(psi1)
        freq = freq_maker(M)
        freqx, freqy = np.meshgrid(freq, freq, sparse=False, indexing="ij")
        psihat2 = psihat1 * np.exp(-1j* eps*dt*4*np.pi**2*(freqx**2+freqy**2)/(b-a)**2)
        psi2 = fft.ifft2(psihat2)
        psi[i] = psi2 * np.exp(-1j*((x**2+y**2)/2+k1*np.abs(psi2)**2)*dt/(2*eps))

    return t, X, Y, psi



def timedip_gp(M, N, a, b, psi0, dt, save_each=30):

    psi = np.zeros((N, M, M), dtype=complex)

    x = np.linspace(a, b, M, endpoint=False)
    y = np.linspace(a, b, M, endpoint=False)
    X, Y = np.meshgrid(x, y, sparse=False, indexing="ij")
    t = np.linspace(0, N*dt, N, endpoint=False)

    psi[0,:] = psi0(x, y)

    for i in range(1, N):
        p = psi[i-1,:]


    return t, X, Y, psi



def mean_value(f, psi, a, b, M):
    """
    Return the mean value of a function evaluated on a square grid of size
    (b-a)^2 with M^2 points on it w.r.t. the probability density defined by
    the wavefunction psi.
    ...

    Parameters
    ----------
    f : function, 2 arguments
        The function of which calculate the mean value. First argument should
        be the x coordinate and the second the y coordinate.
    psi : numpy matrix
        Wave function that defines the probability deensity.
    a : float
        Beginning of the two axes.
    b : float
        Ending of the two axes.
    M : int
        Number of points per axis.

    Raises
    ------
    RuntimeError
        If the size of psi don't match with the gird of paramethes a, b and M.

    Returns
    -------
    scalar
        mean value of the function f.

    """
    delta = np.abs(b-a)/M
    #this is the area element for the case of a square grid. a,b represent the limits of the square in 2D
    dA = delta**2

    x = np.linspace(a, b, M, endpoint=False)
    y = np.linspace(a, b, M, endpoint=False)
    X, Y = np.meshgrid(x, y, sparse=False, indexing="ij")

    if psi.shape == x.shape:
        return np.sum(f(X,Y) * np.abs(psi)**2 * dA)
    else:
        raise RuntimeError("Size of psi should match the size of the grid.")
